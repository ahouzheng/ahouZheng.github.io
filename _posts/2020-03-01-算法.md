---
title: 算法
auther: ahou
layout: post
---

## 二分查找


## LRU
**参考文章：https://www.cnblogs.com/lzrabbit/p/3734850.html#f1**
LRU(least recent used) 最新最小使用
实现方式：
- LinkedHashMap，初始化中accessOrder 设置true，有大小限制时，可以重写removeEldestEntry(),在size大于设定值时返回true。
继承或者代理LinkedHashMap
- 链表+hashMap，自己维护。


## 平衡二叉搜索树 AVL  
**参考文章：https://blog.csdn.net/qq_34840129/article/details/80728186**  
普通二叉搜索树生成过程中，如果数据顺序插入，会造成树部分子树高度相差过大，深度过高影响效率。  
而平衡二叉树在生成过程中，会对树进行旋转，保证树的平衡性，即任意节点的左右子树高度差小于等于1。  
树的不平衡分为四种，分别标记为LL，RR，LR，RL。
- LL，节点a左子树较深，新插入节点位于a的左子树的左子树。此时进行**右旋**
- RR，节点a右子树较深，新插入节点位于a的右子树的右子树。此时进行**左旋**
- LR，节点a左子树较深，新插入节点位于a的左子树的右子树。此时先进行**左旋**（调整为LL），然后进行**右旋**
- RL，节点a右子树较深，新插入节点位于a的右子树的左子树。此时先进行**右旋**（调整为RR），然后进行**左旋**


## 红黑树
红黑树是可以实现高效查找的自平衡二叉树，二叉搜索树可以显著提高查找效率，但二叉树严重不平衡时其查找效率可能退化为链表，因此出现了平衡二叉树 AVL，红黑树等结构  
红黑树每个节点的最长子树不超过最短子树长度的两倍，而AVL树中要求更严格，每个节点最长子树与最短子树长度不超过1，相对于AVL，红黑树的调整会相对少，插入效率更高  

#### 红黑树性质
1. 节点分为红色和黑色
2. 根节点必为黑色
3. 叶子节点必为黑色且为null
4. 不会出现连续的红色节点，即红色节点子节点必为黑色节点
5. 从任意节点出发到它的叶子节点路径中黑色节点数目相等
6. 新建节点为红色节点（如果为黑色，新插入节点会导致5不满足，调整麻烦）

通过性质5和6可以保证红黑树的查找最差的路径长度不会超过最短路径的2倍，由于不会出现连续的红节点，最短的路径全为黑色节点，最长的应该是红黑相间，由于任意叶子节点到根节点的路径中黑色节点数目相等，那最短路径=n个黑色节点，最长路径=n个黑色节点+n个红色节点=2*最短路径

#### 红黑树的插入
插入节点为红色，当其父节点P也为红色时，违背性质4
这时候会有几种情况
1. 新插入节点N的叔叔U节点也为红色，P和U变为黑色，P和U的父节点G变为红色
2. 新插入节点N的叔叔节点U为黑色，这是需要进行旋转调整
    - 左左，P是其父节点G的左子节点，N是P的左子节点，右旋，P变黑，G变红即可
    - 左右，P是其父节点G的左子节点，N是P的右子节点，左旋变为**左左**，然后右旋调整
    - 右右，左左相反对应
    - 右左，左右相反对应


## KMP
**参考文章：[labuladong](https://zhuanlan.zhihu.com/p/83334559)
[article2](https://www.sohu.com/a/336648975_453160)**
KMP（Knuth-Morris-Pratt）算法是一个字符串匹配算法   一般的暴力字符串匹配类似于滑动窗口，子串作为一个窗口在字符串上滑动，每次从头匹配，当匹配失败时滑动一位，重新从头匹配  
这种方法效率低体现在两点：1. 每次从头匹配，2.每次移动一位  
而在KMP算法中，匹配失败在匹配失败位置不需要从头开始匹配，而是根据一个next数组确定状态转移，转移到匹配的最前位置  
例如模式串“str = ABABC”，当在str[4]位置匹配字符C失败时，不必移动到0，可以移动到str[2]接着尝试
**ABAB**AAABB-
**ABAB**C-
当前匹配失败时，可以转化为
AB**AB**AAABB
----**AB**ABC

这里使用的就是模式串当前位置子串的公共前后缀在位置C处，第一个AB和第二个AB就是相同的前缀和后缀
在移动时使前缀移动到后缀的位置，此时依然匹配  
**也就是说，当我们已经匹配了n为的时候，遇到匹配失败，我们不用重新匹配，而是根据前n位中的最长重复前后缀值来进行移动，可以直接从最长匹配前后缀的长度位置开始匹配，比如ABABC在前四个字符中，AB是就是匹配的前后缀**


## 图

#### 单源最短路径
从一个点s出发，到图中任意点的最短路径

#### 最短路径算法
**参考文章：[article1](https://www.zhihu.com/question/20630094/answer/758191548)**  
Dijkstra（迪克斯特拉）算法,单源最短路算法  
该算法可用于计算一个点s到图中所有其他点的最短路径，需要用到两个集合S和U，其中S中用于存储已经计算出最短路径的节点，U中用于存储其他节点，初始时S为空，U中包含所有节点  
算法每次从U中选择一个距离S中节点距离最近的点，移入S，当U为空时，算法结束  
U中节点还存储到节点s的距离，初始时与s有连接的点距离为连接权重，没有的是无穷大，每次有节点移入S时，更新U中距离
首先将节点s放入S，因为d<s-s>=0,一定最小
- 遍历与S中节点相连的节点，如果到集合S小于原值则更新
- 从集合U中选择到集合S距离最小的节点，放入集合S，U不为空返回上一步
**该算法的原理是把找到最短路径的节点放入集合S，那么集合S相当于代表了节点s，一个点到集合S的距离最小说明已经找到了到节点s的最短路径**

#### 最小生成树
最小生成树算法有Prime和Kruskal  
**Prime算法基本思想：** 选定一个根节点，选择离最小树中节点最近的节点（边权重最小）加入最小树，更新余下节点到最小树的距离，重复计算  


#### 图的拓扑排序
拓扑排序是对有向无环图来说的，排序的结果是当存在从a指向b的边时，拓扑排序的结果中a在b的前面，所以图中不能有环

**实现思想：** 从图中找出入度为0的点，它们一定是起点，将这些点加入排序列表，同时删除以这些节点为起点的边，然后重复上面操作寻找入度为0的点

#### 图的关键路径
**参考文章：[article1](https://blog.csdn.net/hh66__66hh/article/details/83418423)
[article2](https://www.sohu.com/a/276900874_100123073)**  
在工程中，要实现一个产品的制造，涉及多个过程，有些可并行，有些有前后顺序，必须串行，制造过程可以通过图来表示   
AOE（Activity On Edge Network）网络中，节点表示事件，边表示活动，例如
![AOE网络](/images/1586253968559.png)
图的关键路径考虑的是有向无环图，边的权重不能为负值，在图中，从源点到汇点的路径中，最长路径就是关键路径  
**关键路径可以表示一个生产过程所要花费的最长时间，已经影响该时间的生产环节，只有优化关键路径上的生产时间才能加快生产速度**

**源点：** 入度为0的点
**汇点：** 出度为0的点

节点有最早开始时间和最晚开始时间，只有最早开始时间等于最晚开始时间的节点才是属于关键路径的节点

**寻找关键路径的算法思想：**
- 按照拓扑排序顺序确定最早开始时间
- 反向确定最晚开始时间
- 最早开始时间和最晚开始时间相同的节点在关键路径上